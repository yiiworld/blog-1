<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 翻译 | forecho]]></title>
  <link href="http://blog.forecho.com/categories/fan-yi/atom.xml" rel="self"/>
  <link href="http://blog.forecho.com/"/>
  <updated>2016-07-08T02:14:06+00:00</updated>
  <id>http://blog.forecho.com/</id>
  <author>
    <name><![CDATA[forecho]]></name>
    <email><![CDATA[caizhenghai@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[如何阅读一本书]]></title>
    <link href="http://blog.forecho.com/how-to-read-a-book.html"/>
    <updated>2016-01-29T07:36:58+00:00</updated>
    <id>http://blog.forecho.com/how-to-read-a-book</id>
    <content type="html"><![CDATA[<blockquote>
  <p>大致翻译了一下，有些没看懂。😓</p>
</blockquote>

<h2 id="section">买更多的书</h2>

<p>每次买3-10本书，至少让自己有5本待读的书，让自己找不出「没有书可以读」的借口。</p>

<h2 id="section-1">一次读三本书</h2>

<p>同一时间阅读三四本书，可以根据自己的心情和天气，小说和非小说类型随时切换着看。</p>

<p>第一本书卡住了，可以看第二本书。</p>

<!--more-->

<h2 id="section-2">喜欢它，讨厌它，摧毁它。</h2>

<p>你可以完全不用按照页码的方式去阅读。用你想阅读的方式去阅读。这本书是你的，你想怎么用就怎么用。</p>

<p>如果你不喜欢某个页面，扯开。如果你不喜欢一个章，跳过它。如果你想浏览一本书，阅读你感兴趣的章节，想做就做，下一本书。不要感到内疚。</p>

<h2 id="section-3">快速决定</h2>

<p>如果你开始读一本书，你觉得你不喜欢它。把它放在一边一段时间，开始一个新的。一个月后试着用不同的心态再去读一遍。</p>

<p>如果你仍然不能读，当礼物送给朋友，然后忘记它。不要因为你买了它就代表着你必须要看完。大多数人都被一本书卡住了不能做其他事情。</p>

<h2 id="section-4">你自己做决定</h2>

<p>一本书总是像你想的那么好。买家的评论很好，但即使我们都买了同一本书，我们会读一个不同。书是很神奇的，阅读和解释它们根据情况我们完全不同。</p>

<h2 id="section-5">总是带一本书</h2>

<p>每次你在公共汽车/火车/午餐休息看手机，你也可以改变去读3页的书。</p>

<h2 id="section-6">我的技巧「阅读」两次。</h2>

<p>看书对我们两次有神奇的效果。我们第一次读一本书我们经常关注作者的故事和事件。</p>

<p>第二次我们读一本书与更深的情感层面。</p>

<hr />

<p>这七个规则不仅帮助我阅读更多，而且更有效率。</p>

<blockquote>
  <p>来源 <a href="https://medium.com/desk-of-van-schneider/how-to-read-a-book-ee402ff8e754#.wrr4epava">How To Read A Book</a></p>
</blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[塑造成功框架的哲学]]></title>
    <link href="http://blog.forecho.com/successful-framework-philosophies.html"/>
    <updated>2015-12-27T14:37:01+00:00</updated>
    <id>http://blog.forecho.com/successful-framework-philosophies</id>
    <content type="html"><![CDATA[<blockquote>
  <p>来源：<a href="http://www.capitalone.io/blog/successful-framework-philosophies/">Philosophies that Shaped Successful Frameworks</a></p>
</blockquote>

<p>在过去的十年里我们看到了许多软件框架的出现，像 <a href="http://spring.io/">Spring</a> 和 <a href="http://rubyonrails.org/">Ruby on Rails</a> 已经是非常成功的框架了，掌握它们就意味着打开多扇就业机会的大门了。然而，对于每一个框架的成功，背后的大多数开发人员都不被人关注。2008年1月1日<a href="https://en.wikipedia.org/wiki/Software_framework">维基百科</a> 列出了67个 Web 框架。然而今天，超过三分之二的消失在列表中或在三年内没有更新。作为 Yii 框架的创造者，我花了很多时间调查各种框架和理解为什么有些成功，有些失败了。我将描述我发现塑造成功框架的一些哲学。</p>

<h2 id="section">为什么框架?</h2>

<p>建立一个成功的框架，重要的是要了解什么是框架，开发人员为什么需要它们。</p>

<p><a href="https://queue.acm.org/detail.cfm?id=1017005">Douglas C. Schmidt 等人</a> 认为框架作为一个集成的软件构件(如类、对象和组件)集合，为相关应用程序提供一个可重用的体系结构。根据这一定义，
框架应该是一个已完工的应用骨架组成可重用和可定制的组件。开发人员将扩展并定制一个框架通过提供他们的应用程序和领域特定逻辑来形成一个完整的应用程序。</p>

<p>一个框架典型的特征就是所谓的控制反转（<a href="http://martinfowler.com/bliki/InversionOfControl.html">inversion of control</a>）。框架通常扮演着组织主程序的角色和调用应用程序代码。这里是反过来的控制流——它调用我而不是我调用框架。下图说明了框架之间的关系，函数库，和应用程序。注意框架通常提供现成的功能的库，以帮助开发人员构建应用程序更快。</p>

<p><img src="https://segmentfault.com/img/bVtewA" alt="" /></p>

<p>开发人员使用框架最重要的原因是框架如何提高生产力和帮助提高代码质量。例如，现代的框架(例如，django)，经常提供代码生成工具或样板帮助立即启动新项目。此外，精心设计的框架内嵌安全保护措施，帮助预防开发人员犯典型的安全漏洞。</p>

<p>企业使用框架，还有一个额外的好处是，它可以应用在整个企业，帮助执行标准。框架提供了记录模式，详细的设计和实现的工具用于在所有应用程序之间提供一个一致的结构。例如，在 Capital One (译者注：薛强所在的公司) 我们开发一个 「Chassis」的框架作为一个集成的基础，统一了许多厂商和顾客公司内部开发应用程序的 API。</p>

<p>当然，并不是所有的开发人员喜欢使用框架。一些一致的抱怨包括陡峭的学习曲线，框架耦合性比较高，性能较低，等等。今天，在这篇文章中我将为你解释现代框架如何的解决这些问题，让大多数的这些抱怨不再适用。</p>

<!--more-->

<h2 id="section-1">哲学</h2>

<p>像任何一个产品一样，一个框架的成功取决于许多因素，包括其背后的思想，代码质量、文档，周围社区，营销，支持，等等。在我看来，特别重要的一项是考虑当一个框架被设计和开发的哲学。</p>

<p>好久以前 Python 开发者 Tim Peters 开发 Python 时发表了被称为 <a href="https://www.python.org/dev/peps/pep-0020/">Python 之禅</a> 的二十格言设计原则。『优美胜于丑陋，明了胜于晦涩，简洁胜于复杂……』他们鼓舞了许多<a href="https://redd.it/15itwl">类似的编程语言之禅（similar programming language zens）</a>，我发现这些格言是适用于框架设计的。根据我的框架开发经验，我特此冷凝和总结我认为任何成功的框架最重要的哲学。</p>

<ul>
  <li>越简单越好</li>
  <li>整体设计是最糟糕的</li>
  <li>一致性</li>
  <li>明了胜于晦涩</li>
  <li>约定大于配置</li>
</ul>

<h2 id="section-2">越简单越好</h2>

<p>让开发人员转换一个新的框架从来都不是一件容易的事。然而，当开发人员选用框架，会作为重点依靠它来投资当前和未来的项目。此外，不想使用类库 - 开发人员可以学习一个 API 实现它 - 学习框架要求开发人员在投入实际使用之前要充分理解框架规则。因此，重要的是要确保简单的设计一个框架，使它更容易、有趣，而且容易去学习，接受和利用。</p>

<p>为了实现简单，一个框架应该强制执行一定数量的限制规则；同时，这些规则应以统一的方式设计和有良好的文档记录。框架执行更多的规则，陡峭的学习曲线，让开发人员很难接受。当规则是一致的，开发人员可以更快学习它们。没有文档，一个框架是无用的。因为没有人会花时间反向工程其规则。</p>

<p><a href="http://alirizhi.com/">Express.js framework</a> 框架路由语法规则的设计是一个很好的例子，一个非常受欢迎的 web 应用服务器框架。而路由在 web 应用程序中是一个重要的概念，是确定应用程序如何响应客户端请求一个特定的端点（一个HTTP方法和一个URI）。Express.js 介绍一个简单的规则来定义一个路线，<code>app.METHOD(PATH, HANDLER)</code>，<code>METHOD</code> 是一个 HTTP 请求方法(例如 GET、POST)，<code>PATH</code> 是服务器上的一个 URI 路径，<code>HANDLER</code> 是回调函数路线相匹配时要执行的。下面的代码片段显示了 Express.js 路由代码的样子。</p>

<p>&#8220;`javascript
var express = require(‘express’);
var app = express();</p>

<p>// accept homepage request 
app.get(‘/’, function (req, res) {
  res.send(‘Hello World!’);
});</p>

<p>// accept POST request at /user 
app.post(‘/user’, function (req, res) {
  res.send(‘Got a PUT request at /user’);
});</p>

<p>// accept DELETE request at /user 
app.delete(‘/user’, function (req, res) {
  res.send(‘Got a DELETE request at /user’);
});
&#8220;`
上面的代码是不言自明的，因为它像是如何去看一个 HTTP 请求。因此,开发人员只需要很少的努力去学习就记住这个路由语法并且把它的实用性应用到自己的项目中。</p>

<h2 id="section-3">整体设计是最糟糕的</h2>

<p>这里的术语「整体」指的是以一个以紧密耦合的代码库为基础构建的框架。web 框架刚开始流行时，他们往往是一个整体，因为他们的主要目标是提供全方位的快速的 web 应用程序开发。渐渐地，人们意识到整体框架有很多问题。例如，
即使改变是框架完全无关的一小部分需要重新测试和释放整个，从而导致应用程序的框架要重建。实际上，整体框架的中代码耦合使得它非常难以保持不同版本的向后兼容性。比如专业缓存、日志、数据库，人们变得不那么愿意被绑定到一个单一的整体框架。</p>

<p>现代框架往往是松散耦合的体系结构。全栈框架（例如 Spring ）已经演变成由松散耦合的组件可以单独使用或与第三方交换的框架。专门的框架是有明确的契约，以支持更好的互操作性，这使得应用程序不依赖于特定的框架。例如，一个非常受欢迎的 web 路由框架的特点是所谓『Sinatra-type 框架』，如 <a href="http://www.sinatrarb.com/">Sinatra</a>，<a href="http://expressjs.com/">Express.js</a> 和 <a href="http://martini.codegangsta.io/">Martini</a>。这些框架使用以下中间件管道架构支持请求路由和处理web应用程序。框架本身是非常小的,但开放式体系结构允许他们无限丰富的各种中间件组件。</p>

<p><img src="https://segmentfault.com/img/bVtewC" alt="" /></p>

<h2 id="section-4">一致性</h2>

<p>一致性意味着一个框架，坚持使用统一的设计，命名约定，代码风格，代码组织等等。一个一致性的框架将降低门槛，因为用户可以学习框架一个方面，并且应用相同的模式，去快速学习其他的结构。一致还可以帮助用户减少框架特征错别字或误用的可能性。</p>

<p>例如，当设计 Yii 框架的 query builder ，我们把一致性作为一个指导标准。查询构建器（query builder）允许您以编程方式创建一个数据库无关的 SQL 语句，避免 SQL 注入攻击。为了帮助用户更容易地记住它的 API ,我们介绍了链式接口和命名后相应的 SQL 关键字的方法。下面的代码片段显示了如何使用 SQL 语句查询构建器设计。</p>

<p><code>php
(new Query())
    -&gt;select('id, email')
    -&gt;from('user')
    -&gt;orderBy('last_name, first_name')
    -&gt;limit(10)
    -&gt;all();
</code>
上面的代码将生成和执行 MySQL 声明如下:</p>

<p><code>sql
SELECT `id`, `email`FROM `user`ORDER BY `last_name`, `first_name`LIMIT 10
</code></p>

<p>正如您可以看到的，代码读取非常类似于你编写 SQL 语句。查询构建器之间的一致性和 SQL 语法很容易学习查询生成器。</p>

<h2 id="section-5">显示大于隐式</h2>

<p>关于编写自己的代码显式大于隐式，避免过多的使用 “自动魔法”，有两个原因坚持这种哲学。首先，显示的代码更容易理解和维护。由于代码是自解释的，维护人员可能不是代码的原作者，不需要来回跳转找到实际上执行的代码。其次，显示的代码不容易出错。虽然显示的可能需要编写更多的代码行，它减少了看似简单含蓄确笼罩着重要的代码的情况。</p>

<p>看看下面的两个 ORM (对象关系映射) 在 PHP 的代码。他们都希望实现『订单』数据库记录和『客户』DB 记录之间建立外键引用约束的相同的目标。</p>

<p><code>
$order-&gt;link('customer', $customer);
</code>
与</p>

<p><code>
$order-&gt;customer = $customer;
</code></p>

<p>第一个版本是正常的方法调用。第二个版本看起来更酷，因为复杂的数据库连接操作可以通过一个看似简单的任务来完成。然而，这是一种错觉，第二个版本的简单性是由其他地方的的复杂性隐藏掩盖。例如，用户不得不通过某种形式的文档来学习这种特殊的赋值语法，以便在实践中使用它。因为链接操作看起来像一个正常分配时，用户可能会忘记处理由它引起的潜在的异常，从而导致整个程序发生故障。</p>

<p>事实上，Yii 的发展过程中，关于两个版本我们讨论了很多，并最终选定了第一个版本，它已收到投诉很少。</p>

<h2 id="section-6">约定大于配置</h2>

<p>约定大于配置的概念已经存在好多年了。这个想法是一个框架应该采取坚持的公约，遵守约定同时仍然允许通过配置提高扩展性。决策的目标是减少开发人员需要做的数目，从而实现哲学# 1——简单性。</p>

<p>约定大于配置最早在 Ruby on Rails 框架中开始流行。Rails 提供一个 ActiveRecord 库，用类和数据库中的表之间的映射处理。按照惯例，表名是类名的多元化形式。因此，该类账户将有一个表称为帐户。如果该表不命名这种方式，用户将必须显式配置类名和表名称之间的映射关系。</p>

<p>许多 MVC 框架使用约定大于配置请求路由到特定的代码片断。如下图所示,<a href="http://sailsjs.org/">Sails.js framework</a> 框架使用的约定，其中的 <code>/we/say/hi</code> URL请求将被路由到<code>controllers/we</code>目录下 SayController 控制器类的<code>hi</code> 动作。按照本约定，开发人员不再需要对控制器的行为定义路由规则。但是，如果开发人员想要使用一个不同的路由规则，他们仍然可以通过显式绑定一个路由到一个控制器动作。</p>

<p><img src="https://segmentfault.com/img/bVtewD" alt="" /></p>

<p>约定优于配置有助于减少需要编写的代码量。然而，它会给开发人员需要遵守规则引入了额外的成本。同时，也往往与前面讨论的『显示大于隐式』的哲学相冲突。事实上，虽然早期版本的 Spring 框架使用了似的 Sails.js 路由约定，Spring 现在要求开发者通过注释明确指定映射。因此，当决定是否引入新的规则以支持约定大于配置，应采取明智的判断。</p>

<h2 id="section-7">总结</h2>

<p>建设一个成功的框架是所有关于功能和简洁性之间的平衡。整个构建框架的过程中，取舍经常需要以坚守，并举例说明，上述哲学加以考虑。</p>

<p>有时候，你可能会遇到其中一个理念是与另一个直接冲突的情况。一致性是比简单更重要？在约定比显性更重要？在这种情况下，<strong>请记住，一个框架的最终目标是简化开发人员的工作，并简化代码的编写进程。因此，保持它的简单和直接。</strong>如果他们有明确性冲突，因为前者会带来隐藏的复杂性可以牺牲约定。同样，如果坚持一致性可以稍微违反严格会造成额外的并发症。</p>

<p>Posted Dec 15, 2015 by…</p>

<p><img src="https://segmentfault.com/img/bVtewE" alt="" />
<strong>Qiang Xue</strong></p>

<p>软件工程师LEAD、技术人员</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何让团队里的工程师对工作不厌烦]]></title>
    <link href="http://blog.forecho.com/coding-is-boring-unless.html"/>
    <updated>2015-11-30T09:40:35+00:00</updated>
    <id>http://blog.forecho.com/coding-is-boring-unless</id>
    <content type="html"><![CDATA[<blockquote>
  <p>原文：<a href="https://blog.enki.com/coding-is-boring-unless-4e496720d664#.pgkeq1x6r">《Coding is boring, unless…》</a></p>
</blockquote>

<p>作为一名工程师,我从来没有坚持同样的工作超过两年了。</p>

<p>每个新工作是一个不错的职业选择,高薪在我们行业中也是很常见的。但是我离职让我之前的老板不是很高兴。其中一些试着说服我,但是我觉得留下来很无聊,所以我不能留下来。</p>

<p>（免责声明：我很幸运的生活在一个编程工作比程序员更多的地方，所以我换工作有很多选择的余地。）</p>

<p>我现在作为 <a href="http://enki.com/">Enki</a> 公司的联合创始人兼首席技术官。因此,我负责了公司的工程师文化。我工作的一部分是要确保我们的开发人员不会像我过去有时候一样的无聊。</p>

<p>为了帮助我们的团队，我们已经设计了一些策略对抗无聊并且已经应用到我们公司。因为这种策略目前运行良好,我想在这里分享下。</p>

<!--more-->

<p>在 Enki，我们幸运的在一个具有挑战性的问题。我们有很多有趣的事情需要编码和很多有趣的谜题来解决。因此『无聊』并不觉得一个紧迫问题</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP 中的动态属性和 StdClass]]></title>
    <link href="http://blog.forecho.com/dynamic-properties-in-php-and-stdclass.html"/>
    <updated>2015-11-08T13:52:15+00:00</updated>
    <id>http://blog.forecho.com/dynamic-properties-in-php-and-stdclass</id>
    <content type="html"><![CDATA[<blockquote>
  <p>翻译 <a href="http://krisjordan.com/dynamic-properties-in-php-with-stdclass">Dynamic Properties in PHP and StdClass</a></p>
</blockquote>

<p>JavaScript 和 Python 允许对象实例的动态属性。事实证明,PHP 也是如此。看官方 PHP 对象和类文档可能会导致你相信动态实例属性需要自定义 __get 和 __set 魔术方法。其实不用。</p>

<h2 id="section">简单,内置的动态属性</h2>

<p>看看以下代码:</p>

<p><code>php
class DynamicProperties { }
$object = new DynamicProperties;
echo isset($object-&gt;foo) ? 't' : 'f'; // f
echo PHP_EOL;
// Set Dynamic Properties foo and fooz
$object-&gt;foo = 'bar';
$object-&gt;fooz = 'baz';
// Isset and Unset work
isset($object-&gt;foo); // true
unset($object-&gt;foo);
// Iterate through Properties and Values
foreach($object as $property =&gt; $value)  {
    echo $property . ' = ' . $value . PHP_EOL;
}
// Prints:
// fooz = baz
</code></p>

<!--more-->

<p>使用内置动态实例属性的速度比使用魔法 __get 和 __set 方法快一个数量级（30倍,通过我的分析）。在 PHP 中动态属性访问时是没有回调方法。</p>

<p>因此,什么情况下需要使用 __get 和 __set 呢？如果你需要更复杂的行为,比如需要计算属性,你必须使用__get和__set。另外，如果你不愿意让类拥有动态属性你可以使用__get和__set抛出错误。</p>

<h2 id="stdclass-anonymous-objects">StdClass: Anonymous Objects</h2>

<p>有时一个属性包扔到键值对是必要的。一种方法是使用数组,但这需要引用所有的键。另一种方法是使用动态属性 StdClass 的实例。StdClass 是 PHP 中没有预定义的成员属性的特殊类。</p>

<p><code>
$object = new StdClass;
$object-&gt;foo = 'bar';
json_encode($object);
</code></p>

<p>接下来我使用 SPL’s 的 Countable 和 ArrayAccess 可以实现下面的几个动作:</p>

<p><code>
class MyClass implements Countable, ArrayAccess { ... }
$myObject = new MyClass();
// Using array access notation
$myObject[0] = 'hello';
$myObject[1] = 'world';
$myObject['foo'] = 'bar';
</code></p>

<p>实现动态属性功能并不需要继承 stdClass！</p>
]]></content>
  </entry>
  
</feed>
